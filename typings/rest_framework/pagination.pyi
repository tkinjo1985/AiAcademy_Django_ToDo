"""
This type stub file was generated by pyright.
"""

from collections import namedtuple
from typing import Any, Optional

"""
Pagination serializers determine the structure of the output that should
be used for paginated responses.
"""
def _positive_int(integer_string, strict: bool = ..., cutoff: Optional[Any] = ...):
    """
    Cast a string to a strictly positive integer.
    """
    ...

def _divide_with_ceil(a, b):
    """
    Returns 'a' divided by 'b', with any remainder rounded up.
    """
    ...

def _get_displayed_page_numbers(current, final):
    """
    This utility function determines a list of page numbers to display.
    This gives us a nice contextually relevant set of page numbers.

    For example:
    current=14, final=16 -> [1, None, 13, 14, 15, 16]

    This implementation gives one page to each side of the cursor,
    or two pages to the side when the cursor is at the edge, then
    ensures that any breaks between non-continuous page numbers never
    remove only a single page.

    For an alternative implementation which gives two pages to each side of
    the cursor, eg. as in GitHub issue list pagination, see:

    https://gist.github.com/tomchristie/321140cebb1c4a558b15
    """
    ...

def _get_page_links(page_numbers, current, url_func):
    """
    Given a list of page numbers and `None` page breaks,
    return a list of `PageLink` objects.
    """
    ...

def _reverse_ordering(ordering_tuple):
    """
    Given an order_by tuple such as `('-created', 'uuid')` reverse the
    ordering and return a new tuple, eg. `('created', '-uuid')`.
    """
    ...

Cursor = namedtuple('Cursor', ['offset', 'reverse', 'position'])
PageLink = namedtuple('PageLink', ['url', 'number', 'is_active', 'is_break'])
PAGE_BREAK = PageLink(url=None, number=None, is_active=False, is_break=True)
class BasePagination:
    display_page_controls = ...
    def paginate_queryset(self, queryset, request, view: Optional[Any] = ...):
        ...
    
    def get_paginated_response(self, data):
        ...
    
    def get_paginated_response_schema(self, schema):
        ...
    
    def to_html(self):
        ...
    
    def get_results(self, data):
        ...
    
    def get_schema_fields(self, view):
        ...
    
    def get_schema_operation_parameters(self, view):
        ...
    


class PageNumberPagination(BasePagination):
    """
    A simple page number based style that supports page numbers as
    query parameters. For example:

    http://api.example.org/accounts/?page=4
    http://api.example.org/accounts/?page=4&page_size=100
    """
    page_size = ...
    django_paginator_class = ...
    page_query_param = ...
    page_query_description = ...
    page_size_query_param = ...
    page_size_query_description = ...
    max_page_size = ...
    last_page_strings = ...
    template = ...
    invalid_page_message = ...
    def paginate_queryset(self, queryset, request, view: Optional[Any] = ...):
        """
        Paginate a queryset if required, either returning a
        page object, or `None` if pagination is not configured for this view.
        """
        self.request = ...
    
    def get_paginated_response(self, data):
        ...
    
    def get_paginated_response_schema(self, schema):
        ...
    
    def get_page_size(self, request):
        ...
    
    def get_next_link(self):
        ...
    
    def get_previous_link(self):
        ...
    
    def get_html_context(self):
        ...
    
    def to_html(self):
        ...
    
    def get_schema_fields(self, view):
        ...
    
    def get_schema_operation_parameters(self, view):
        ...
    


class LimitOffsetPagination(BasePagination):
    """
    A limit/offset based style. For example:

    http://api.example.org/accounts/?limit=100
    http://api.example.org/accounts/?offset=400&limit=100
    """
    default_limit = ...
    limit_query_param = ...
    limit_query_description = ...
    offset_query_param = ...
    offset_query_description = ...
    max_limit = ...
    template = ...
    def paginate_queryset(self, queryset, request, view: Optional[Any] = ...):
        self.count = ...
        self.limit = ...
        self.offset = ...
        self.request = ...
    
    def get_paginated_response(self, data):
        ...
    
    def get_paginated_response_schema(self, schema):
        ...
    
    def get_limit(self, request):
        ...
    
    def get_offset(self, request):
        ...
    
    def get_next_link(self):
        ...
    
    def get_previous_link(self):
        ...
    
    def get_html_context(self):
        ...
    
    def to_html(self):
        ...
    
    def get_count(self, queryset):
        """
        Determine an object count, supporting either querysets or regular lists.
        """
        ...
    
    def get_schema_fields(self, view):
        ...
    
    def get_schema_operation_parameters(self, view):
        ...
    


class CursorPagination(BasePagination):
    """
    The cursor pagination implementation is necessarily complex.
    For an overview of the position/offset style we use, see this post:
    https://cra.mr/2011/03/08/building-cursors-for-the-disqus-api
    """
    cursor_query_param = ...
    cursor_query_description = ...
    page_size = ...
    invalid_cursor_message = ...
    ordering = ...
    template = ...
    page_size_query_param = ...
    page_size_query_description = ...
    max_page_size = ...
    offset_cutoff = ...
    def paginate_queryset(self, queryset, request, view: Optional[Any] = ...):
        self.page_size = ...
        self.base_url = ...
        self.ordering = ...
        self.cursor = ...
        self.page = ...
    
    def get_page_size(self, request):
        ...
    
    def get_next_link(self):
        ...
    
    def get_previous_link(self):
        ...
    
    def get_ordering(self, request, queryset, view):
        """
        Return a tuple of strings, that may be used in an `order_by` method.
        """
        ...
    
    def decode_cursor(self, request):
        """
        Given a request with a cursor, return a `Cursor` instance.
        """
        ...
    
    def encode_cursor(self, cursor):
        """
        Given a Cursor instance, return an url with encoded cursor.
        """
        ...
    
    def _get_position_from_instance(self, instance, ordering):
        ...
    
    def get_paginated_response(self, data):
        ...
    
    def get_paginated_response_schema(self, schema):
        ...
    
    def get_html_context(self):
        ...
    
    def to_html(self):
        ...
    
    def get_schema_fields(self, view):
        ...
    
    def get_schema_operation_parameters(self, view):
        ...
    


